import asyncio
import os
from io import BytesIO

import re
import uuid

import discord
from PIL import Image, ImageDraw, ImageFont
from discord.ext import commands
from discord.ui import View, Button, Modal, TextInput
from discord import TextStyle, File
import traceback
from datetime import datetime, timezone

from typing import Optional

from utils import config
from utils.config import INTERVIEW_PUBLIC_CHANNEL_ID, INTERVIEW_PRIVATE_CHANNEL_ID, WELCOME_CHANNEL_ID, \
    RULES_CHANNEL_ID, ANNOUNCEMENTS_CHANNEL_ID, ACCEPTED_ROLE_ID, MEMBER_CHAT_CHANNEL_ID
from utils.logger import get_logger
from utils.gspread_utils import GSpreadClient # Import GSpreadClient
from utils.config import APPLICANT_ROLE_ID, GUEST_ROLE_ID, MEMBERS_SHEET_NAME, TEST_SHEET_NAME

import datetime

class DecisionButtonView(discord.ui.View):
    def __init__(self, cog, timeout: Optional[float] = None):
        super().__init__(timeout=timeout)
        self.cog = cog
        self.logger = cog.logger

    def _extract_user_id_and_interview_id(self, interaction: discord.Interaction) -> tuple[
        Optional[int], Optional[str]]:
        user_id = None
        interview_id = None
        if interaction.message.embeds:
            embed = interaction.message.embeds[0]
            # Try to find user ID in description first
            mention_match = re.search(r'<@!?(\d+)>', embed.description or "")
            if mention_match:
                user_id = int(mention_match.group(1))

            # Then iterate through fields to find user ID and interview ID
            for field in embed.fields:
                if not user_id: # If not found in description, try finding in fields
                    mention_match = re.search(r'<@!?(\d+)>', field.value)
                    if mention_match:
                        user_id = int(mention_match.group(1))
                if field.name.strip().lower() == "‚ùì interview_id":
                    interview_id = field.value.replace('>', '').strip()
                    break # Assuming interview_id is unique and at most one

        return user_id, interview_id

    @discord.ui.button(label="Ìï©Í≤©", style=discord.ButtonStyle.success, custom_id="approve_button")
    async def approve(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=False) # Defer immediately

        member = interaction.user
        channel = interaction.channel
        self.logger.info(f"‚úÖ {member.display_name} ({member.id}) clicked 'Approve' button in channel '{channel.name}'.")

        if not self.cog.check_staff_role(member):
            await interaction.followup.send("‚ùå You do not have permission to use this button.", ephemeral=True)
            self.logger.warning(f"‚ö†Ô∏è {member.display_name} ({member.id}) attempted to use 'Approve' button without permission.")
            return

        target_member_id, interview_id = self._extract_user_id_and_interview_id(interaction)

        if not interview_id:
            await interaction.followup.send("‚ùå Could not find a valid interview ID in the embed of the message containing this button (missing information).", ephemeral=True)
            self.logger.error(f"‚ùå Failed to extract interview ID from embed. Message ID: {interaction.message.id}")
            return

        target_member = None
        if target_member_id:
            target_member = interaction.guild.get_member(target_member_id)

        if not target_member:
            await interaction.followup.send("‚ùå Could not find the member associated with this channel. Please handle manually.", ephemeral=True)
            self.logger.error(f"‚ùå Could not find member ({target_member_id}) associated with interview ID '{interview_id}' in Discord.")
            return

        if self.cog and self.cog.gspread_client and interview_id:
            try:
                testing_worksheet = await self.cog.gspread_client.get_worksheet(config.TEST_SHEET_NAME, "Sheet1")
                if not testing_worksheet:
                    await interaction.followup.send("‚ùå Could not access the 'Testing' sheet.", ephemeral=True)
                    return

                all_testing_values = await asyncio.to_thread(testing_worksheet.get_all_values)
                if not all_testing_values:
                    self.logger.warning("üü° 'Testing' sheet is empty.")
                    await interaction.followup.send("‚ùå No data found in the 'Testing' sheet.", ephemeral=True)
                    return

                header_testing = [h.strip().lower() for h in all_testing_values[0]]
                interview_data_row = None

                try:
                    interview_id_col_index = header_testing.index("interview_id")
                except ValueError:
                    self.logger.error("‚ùå 'Interview_ID' column not found in 'Testing' sheet.")
                    await interaction.followup.send(
                        "‚ùå The column structure of the 'Testing' sheet is incorrect. 'Interview_ID' column not found.", ephemeral=True)
                    return

                for i, row in enumerate(all_testing_values[1:]): # Skip header row
                    if len(row) > interview_id_col_index and row[interview_id_col_index] == interview_id:
                        interview_data_row = row
                        break

                if not interview_data_row:
                    self.logger.warning(f"üü° Data for interview ID '{interview_id}' not found in 'Testing' sheet.")
                    await interaction.followup.send(
                        f"‚ùå Data for interview ID '{interview_id}' not found in 'Testing' sheet.", ephemeral=True)
                    return

                def get_column_value(row_data, header_list, column_name_lower):
                    try:
                        idx = header_list.index(column_name_lower)
                        return row_data[idx] if idx < len(row_data) else ""
                    except ValueError:
                        return ""

                discord_user_id = get_column_value(interview_data_row, header_testing, "discord_user_id")
                discord_username = get_column_value(interview_data_row, header_testing, "discord_username")
                ingame_name_tag = get_column_value(interview_data_row, header_testing, "Ïù∏Í≤åÏûÑ Ïù¥Î¶Ñ Î∞è ÌÉúÍ∑∏ (Ïòà: Ïù¥Î¶Ñ#ÌÉúÍ∑∏)")
                activity_region = get_column_value(interview_data_row, header_testing, "ÌôúÎèô ÏßÄÏó≠ (ÏÑúÎ∂Ä/Ï§ëÎ∂Ä/ÎèôÎ∂Ä)")
                main_role = get_column_value(interview_data_row, header_testing, "Í∞ÄÏû• ÏûêÏã†ÏûàÎäî Ïó≠Ìï†")
                premier_interest = get_column_value(interview_data_row, header_testing, "ÌîÑÎ¶¨ÎØ∏Ïñ¥ ÌåÄ Ï∞∏Í∞Ä ÏùòÌñ•")
                notes = "" # Assuming notes column exists or can be added

                accepted_date = datetime.date.today().strftime("%Y-%m-%d")

                new_member_data = [
                    discord_user_id,
                    discord_username,
                    accepted_date,
                    ingame_name_tag,
                    activity_region,
                    main_role,
                    premier_interest,
                    notes
                ]

                member_list_sheet_name = config.MEMBERS_SHEET_NAME
                member_list_worksheet_name = "Sheet1" # Assuming Sheet1 for members list

                append_success = await self.cog.gspread_client.append_row(
                    member_list_sheet_name,
                    member_list_worksheet_name,
                    new_member_data
                )

                if not append_success:
                    await interaction.followup.send("‚ùå Failed to add new member to 'Member List' sheet.", ephemeral=True)
                    return

                # Delete from testing sheet after moving
                delete_success = await self.cog.gspread_client.delete_row_by_interview_id(
                    config.TEST_SHEET_NAME,
                    "Sheet1",
                    interview_id
                )

                if not delete_success:
                    self.logger.error(f"‚ùå Failed to delete item for interview ID '{interview_id}' from 'Testing' sheet.")
                    await interaction.followup.send(f"‚ùå Failed to delete item from 'Testing' sheet. Please check manually.", ephemeral=True)

                accepted_role_id = config.ACCEPTED_ROLE_ID
                accepted_role = interaction.guild.get_role(accepted_role_id)
                if accepted_role:
                    await target_member.add_roles(accepted_role, reason="Approved - Role granted")
                    self.logger.info(f"‚úÖ Granted '{accepted_role.name}' role to {target_member.display_name} ({target_member.id}).")
                else:
                    self.logger.warning(f"‚ö†Ô∏è Could not find 'Accepted' role (ID: {accepted_role_id}), so could not grant it to {target_member.display_name}.")

                # Remove applicant and guest roles
                guest_role = interaction.guild.get_role(config.GUEST_ROLE_ID)
                if guest_role and guest_role in target_member.roles:
                    await target_member.remove_roles(guest_role, reason="Approved - Guest role removed")
                    self.logger.info(f"‚úÖ Removed 'Guest' role from {target_member.display_name} ({target_member.id}).")

                applicant_role = interaction.guild.get_role(config.APPLICANT_ROLE_ID)
                if applicant_role and applicant_role in target_member.roles:
                    await target_member.remove_roles(applicant_role, reason="Approved - Applicant role removed")
                    self.logger.info(f"‚úÖ Removed 'Applicant' role from {target_member.display_name} ({target_member.id}).")

                await interaction.followup.send(
                    f"‚úÖ `{target_member.display_name}`'s interview has been approved. Added to 'Member List'.",
                    ephemeral=False
                )
                self.logger.info(f"‚úÖ Interview ID '{interview_id}' approved. Channel awaiting deletion.")

                await self.cog.send_welcome_message(target_member) # Send welcome message on approval
                await self.cog.delete_channel_after_delay(channel, 10, target_member.id, True)

            except Exception as e:
                self.logger.error(f"‚ùå Error during approval process: {e}\n{traceback.format_exc()}")
                await interaction.followup.send(
                    f"‚ùå An error occurred during the approval process. Please check the bot logs for details.",
                    ephemeral=True
                )
                if hasattr(self.cog.bot, 'get_channel') and config.LOG_CHANNEL_ID:
                    log_channel = self.cog.bot.get_channel(config.LOG_CHANNEL_ID)
                    if log_channel:
                        await log_channel.send(
                            f"üö® **Interview Processing Error:** Unexpected error during approval for `Interview ID: {interview_id}`: `{e}`"
                        )
        else:
            await interaction.followup.send("‚ùå Google Sheets client not initialized or interview ID not found.", ephemeral=True)
            self.logger.error("‚ùå Google Sheets client is missing or interview ID not found, cannot proceed with approval.")


    @discord.ui.button(label="ÌÖåÏä§Ìä∏", style=discord.ButtonStyle.secondary, custom_id="interview_test")
    async def test(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)

        if not self.cog.check_staff_role(interaction.user): # Use new staff role check
            self.cog.logger.warning(
                f"{interaction.user.display_name} ({interaction.user.id})ÎãòÏù¥ ÌÖåÏä§Ìä∏ Î≤ÑÌäºÏùÑ ÏÇ¨Ïö©ÌïòÎ†§ ÌñàÏúºÎÇò Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§.")
            return await interaction.followup.send("‚ùå Ïù¥ ÏûëÏóÖÏùÑ ÏàòÌñâÌï† Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§. Í¥ÄÎ¶¨ÏûêÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.", ephemeral=True)

        user_id, interview_id = self._extract_user_id_and_interview_id(interaction)
        if not user_id:
            self.cog.logger.warning(f"ÌÖåÏä§Ìä∏ Ï≤òÎ¶¨ Ïãú user_idÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. Î©îÏãúÏßÄ ID: {interaction.message.id}")
            return await interaction.followup.send("‚ùå ÏßÄÏõêÏûê Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.", ephemeral=True)

        member = interaction.guild.get_member(user_id)
        if not member:
            self.cog.logger.warning(f"ÌÖåÏä§Ìä∏ Ï≤òÎ¶¨ Ïãú Î©§Î≤ÑÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. User ID: {user_id}")
            return await interaction.followup.send("‚ùå ÏßÄÏõêÏûê Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.", ephemeral=True)

        try:
            if self.cog and self.cog.gspread_client and interview_id:
                success = await self.cog.gspread_client.update_row_by_interview_id(
                    config.TEST_SHEET_NAME,
                    "Sheet1",
                    interview_id,
                    "Status",
                    "Testing"
                )
                if not success:
                    self.cog.logger.error(f"‚ùå Google Sheet ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®: {user_id} ÌÖåÏä§Ìä∏ Ï≤òÎ¶¨.")
                    await interaction.followup.send(
                        "‚ùå Google Sheet ÏóÖÎç∞Ïù¥Ìä∏Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Í¥ÄÎ¶¨ÏûêÏóêÍ≤å Î¨∏ÏùòÌïòÏÑ∏Ïöî.",
                        ephemeral=True
                    )
                    return

            test_role = interaction.guild.get_role(APPLICANT_ROLE_ID)
            if not test_role:
                self.cog.logger.error(f"‚ùå ÌÖåÏä§Ìä∏ Ïó≠Ìï† ID {APPLICANT_ROLE_ID}ÏùÑ(Î•º) Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. ÏÑ§Ï†ï ÌôïÏù∏ ÌïÑÏöî.")
                return await interaction.followup.send("‚ùå ÌÖåÏä§Ìä∏ Ïó≠Ìï†ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.", ephemeral=True)

            await member.add_roles(test_role, reason="ÌÖåÏä§Ìä∏ Ïó≠Ìï† Î∂ÄÏó¨ (Í¥ÄÎ¶¨Ïûê ÏäπÏù∏)")
            self.cog.logger.info(f"üü° {member.display_name} ({member.id})ÎãòÏóêÍ≤å ÌÖåÏä§Ìä∏ Ïó≠Ìï† '{test_role.name}'ÏùÑ(Î•º) Î∂ÄÏó¨ÌñàÏäµÎãàÎã§.")

            try:
                await member.send(
                    "ÏïàÎÖïÌïòÏÑ∏Ïöî.\n\n"
                    "Exceed ÌÅ¥ÎûúÏóê ÏßÄÏõêÌï¥ Ï£ºÏÖîÏÑú ÏßÑÏã¨ÏúºÎ°ú Í∞êÏÇ¨ÎìúÎ¶ΩÎãàÎã§.\n"
                    "ÏßÄÏõêÏûêÎãòÏùò Í∞ÄÎä•ÏÑ±Í≥º Ïó¥Ï†ïÏùÑ ÎçîÏö± ÏïåÏïÑÎ≥¥Í∏∞ ÏúÑÌï¥ **ÌÖåÏä§Ìä∏ Ïó≠Ìï†**ÏùÑ Î∂ÄÏó¨ÎìúÎ†∏ÏäµÎãàÎã§.\n\n"
                    "Ìï¥Îãπ Ïó≠Ìï†ÏùÑ ÌÜµÌï¥ ÌÖåÏä§Ìä∏ Í∏∞Í∞Ñ ÎèôÏïà ÏÑúÎ≤ÑÏóêÏÑú ÏûêÏú†Î°≠Í≤å ÌôúÎèôÌï¥ Ï£ºÏãúÍ≥†,\n"
                    "Ïö¥ÏòÅÏßÑÏùÄ ÏßÄÏõêÏûêÎãòÏùò ÌôúÎèô Î∞è ÏÜåÌÜµÏùÑ Î∞îÌÉïÏúºÎ°ú ÏµúÏ¢Ö Í≤∞Ï†ïÏùÑ ÎÇ¥Î¶¨Í≤å Îê©ÎãàÎã§.\n\n"
                    "ExceedÎäî ÌåÄÏõåÌÅ¨ÏôÄ Ïª§ÎÆ§ÎãàÌã∞ Î∂ÑÏúÑÍ∏∞Î•º Ï§ëÏãúÌïòÎäî ÎßåÌÅº,\n"
                    "ÌÖåÏä§Ìä∏ Í∏∞Í∞Ñ Ï§ë Ï†ÅÍ∑πÏ†ÅÏù∏ Ï∞∏Ïó¨ÏôÄ Í∏çÏ†ïÏ†ÅÏù∏ ÏÜåÌÜµÏùÑ Í∏∞ÎåÄÌïòÍ≤†ÏäµÎãàÎã§.\n\n"
                    "Í∂ÅÍ∏àÌïòÏã† ÏÇ¨Ìï≠Ïù¥ÎÇò Î∂àÌé∏Ìïú Ï†êÏù¥ ÏûàÏúºÏãúÎ©¥ Ïñ∏Ï†úÎì†ÏßÄ Ïö¥ÏòÅÏßÑÏóêÍ≤å Î¨∏ÏùòÌï¥ Ï£ºÏÑ∏Ïöî.\n"
                    "Î¨∏ÏùòÎäî ÏïÑÎûò Ï±ÑÎÑêÏùÑ ÌÜµÌï¥ Ï£ºÏÖîÎèÑ Îê©ÎãàÎã§:\n\n"
                    "https://discord.com/channels/1389527318699053178/1389742771253805077\n\n"
                    "Îã§Ïãú ÌïúÎ≤à ÏßÄÏõêÌï¥ Ï£ºÏÖîÏÑú Í∞êÏÇ¨ÎìúÎ¶¨Î©∞, ÏïûÏúºÎ°úÏùò ÌôúÎèôÏùÑ Í∏∞ÎåÄÌïòÍ≤†ÏäµÎãàÎã§!\n\n"
                    "Í∞êÏÇ¨Ìï©ÎãàÎã§.\n\n"
                    "üìå *Ïù¥ Î©îÏãúÏßÄÎäî ÏûêÎèô Î∞úÏÜ°ÎêòÏóàÏúºÎ©∞, Ïù¥ Î¥áÏóêÍ≤å ÏßÅÏ†ë ÎãµÏû•ÌïòÏÖîÎèÑ Ïö¥ÏòÅÏßÑÏùÄ ÎÇ¥Ïö©ÏùÑ ÌôïÏù∏Ìï† Ïàò ÏóÜÏäµÎãàÎã§.*"
                )
                self.cog.logger.info(f"üü° {member.display_name}ÎãòÏóêÍ≤å ÌÖåÏä§Ìä∏ ÏïàÎÇ¥ DM Ï†ÑÏÜ° ÏôÑÎ£å.")
            except discord.Forbidden:
                self.cog.logger.warning(f"üü° {member.display_name} ({member.id})ÎãòÏóêÍ≤å DMÏùÑ Î≥¥ÎÇº Ïàò ÏóÜÏäµÎãàÎã§. (DMÏù¥ ÎπÑÌôúÏÑ±ÌôîÎêòÏóàÍ±∞ÎÇò Ï∞®Îã®Îê®)")
                await interaction.followup.send(
                    f"üü° {member.mention}ÎãòÏóêÍ≤å ÌÖåÏä§Ìä∏ Ïó≠Ìï†ÏùÑ Î∂ÄÏó¨ÌñàÏäµÎãàÎã§. (DM Ï†ÑÏÜ° Ïã§Ìå®: DMÏù¥ ÎπÑÌôúÏÑ±ÌôîÎêòÏóàÏùÑ Ïàò ÏûàÏäµÎãàÎã§.)")
                return

            await interaction.followup.send(f"üü° {member.mention}ÎãòÏóêÍ≤å ÌÖåÏä§Ìä∏ Ïó≠Ìï†ÏùÑ Î∂ÄÏó¨ÌñàÏäµÎãàÎã§.")

        except discord.Forbidden:
            self.cog.logger.error(f"‚ùå Ïó≠Ìï† Î∂ÄÏó¨ Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§. Î¥á Í∂åÌïúÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî. {traceback.format_exc()}")
            await interaction.followup.send("‚ùå Ïó≠Ìï† Î∂ÄÏó¨ Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§. Î¥á Í∂åÌïúÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.", ephemeral=True)
        except Exception as e:
            self.cog.logger.error(f"‚ùå ÌÖåÏä§Ìä∏ Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò Î∞úÏÉù: {e}\n{traceback.format_exc()}")
            await interaction.followup.send(f"‚ùå Ïò§Î•ò Î∞úÏÉù: {str(e)}", ephemeral=True)

    @discord.ui.button(label="Î∂àÌï©Í≤©", style=discord.ButtonStyle.danger, custom_id="interview_fail")
    async def reject(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)

        if not self.cog.check_staff_role(interaction.user): # Use new staff role check
            self.cog.logger.warning(
                f"{interaction.user.display_name} ({interaction.user.id})ÎãòÏù¥ Î∂àÌï©Í≤© Î≤ÑÌäºÏùÑ ÏÇ¨Ïö©ÌïòÎ†§ ÌñàÏúºÎÇò Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§.")
            return await interaction.followup.send("‚ùå Ïù¥ ÏûëÏóÖÏùÑ ÏàòÌñâÌï† Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§. Í¥ÄÎ¶¨ÏûêÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.", ephemeral=True)

        user_id, interview_id = self._extract_user_id_and_interview_id(interaction)
        if not user_id:
            self.cog.logger.warning(f"Î∂àÌï©Í≤© Ï≤òÎ¶¨ Ïãú user_idÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. Î©îÏãúÏßÄ ID: {interaction.message.id}")
            return await interaction.followup.send(
                "‚ùå ÏßÄÏõêÏûê Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.",
                ephemeral=True
            )

        member = interaction.guild.get_member(user_id)
        if not member:
            self.cog.logger.warning(f"Î∂àÌï©Í≤© Ï≤òÎ¶¨ Ïãú Î©§Î≤ÑÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. User ID: {user_id}")
            return await interaction.followup.send(
                "‚ùå ÏßÄÏõêÏûê Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.",
                ephemeral=True
            )
        try:
            if self.cog and self.cog.gspread_client and interview_id:
                success = await self.cog.gspread_client.update_row_by_interview_id(
                    config.TEST_SHEET_NAME,
                    "Sheet1",
                    interview_id,
                    "Status",
                    "Rejected"
                )
                if not success:
                    self.cog.logger.error(f"‚ùå Google Sheet ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®: {user_id} Î∂àÌï©Í≤© Ï≤òÎ¶¨.")
                    await interaction.followup.send(
                        "‚ùå Google Sheet ÏóÖÎç∞Ïù¥Ìä∏Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Í¥ÄÎ¶¨ÏûêÏóêÍ≤å Î¨∏ÏùòÌïòÏÑ∏Ïöî.",
                        ephemeral=True
                    )
                    return

            try:
                await member.send(
                    "ÏïàÎÖïÌïòÏÑ∏Ïöî. \n\n"
                    "Î®ºÏ†Ä Exceed ÌÅ¥ÎûúÏóê Í¥ÄÏã¨ÏùÑ Í∞ÄÏ†∏Ï£ºÏãúÍ≥† ÏßÄÏõêÌï¥ Ï£ºÏÖîÏÑú ÏßÑÏã¨ÏúºÎ°ú Í∞êÏÇ¨ÎìúÎ¶ΩÎãàÎã§.\n"
                    "ÏïàÌÉÄÍπùÍ≤åÎèÑ Ïù¥Î≤àÏóêÎäî Ïó¨Îü¨ ÏÇ¨Ïú†Î°ú Ïù∏Ìï¥ Ìï®ÍªòÌïòÏßÄ Î™ªÌïòÍ≤å ÎêòÏóàÏäµÎãàÎã§.\n"
                    "ÏßÄÏõêÏûêÎãòÏùò Ïó¥Ï†ïÍ≥º ÎÖ∏Î†•ÏùÄ Ï∂©Î∂ÑÌûà ÎÜíÏù¥ ÌèâÍ∞ÄÌïòÏßÄÎßå, ÌòÑÏû¨ ÌÅ¥ÎûúÏùò ÏÉÅÌô©Í≥º Îã§ÏñëÌïú ÏöîÏÜåÎì§ÏùÑ Ï¢ÖÌï©Ï†ÅÏúºÎ°ú Í≥†Î†§Ìïú Í≤∞Í≥ºÏûÑÏùÑ ÎÑàÍ∑∏Îü¨Ïù¥ Ïù¥Ìï¥Ìï¥ Ï£ºÏãúÍ∏∏ Î∞îÎûçÎãàÎã§.\n"
                    "ÏïûÏúºÎ°úÎèÑ ÏßÄÏÜçÏ†ÅÏù∏ Î∞úÏ†ÑÏù¥ ÏûàÏúºÏãúÍ∏∏ ÏßÑÏã¨ÏúºÎ°ú ÏùëÏõêÌïòÎ©∞, ÏÉÅÌô©Ïù¥ Í¥úÏ∞ÆÏïÑÏßÄÎ©¥ Ïñ∏Ï†úÎì†ÏßÄ Îã§Ïãú ÏßÄÏõêÌï¥ Ï£ºÏãúÍ∏∏ Î∞îÎûçÎãàÎã§. \n\n"
                    "ExceedÎäî Ïñ∏Ï†úÎÇò Ïó¥Î†§ ÏûàÏúºÎ©∞, Îã§Ïùå Í∏∞ÌöåÏóê Íº≠ Ìï®ÍªòÌï† Ïàò ÏûàÍ∏∞Î•º Í∏∞ÎåÄÌïòÍ≤†ÏäµÎãàÎã§.\n\n"
                    "Í∂ÅÍ∏àÌïú Ï†êÏù¥ ÏûàÏúºÏãúÎ©¥ Ïñ∏Ï†úÎì†ÏßÄ Ïö¥ÏòÅÏßÑÏóêÍ≤å Î¨∏ÏùòÌïòÏãúÍ±∞ÎÇò, ÏïÑÎûò Ï±ÑÎÑêÏùÑ ÌÜµÌï¥ Ïó∞ÎùΩ Ï£ºÏãúÍ∏∞ Î∞îÎûçÎãàÎã§:  \n\n"
                    "https://discord.com/channels/1389527318699053178/1389742771253805077\n\n"
                    "Í∞êÏÇ¨Ìï©ÎãàÎã§.\n\n"
                    "üìå *Ïù¥ Î©îÏãúÏßÄÎäî ÏûêÎèô Î∞úÏÜ°ÎêòÏóàÏúºÎ©∞, Ïù¥ Î¥áÏóêÍ≤å ÏßÅÏ†ë ÎãµÏû•ÌïòÏÖîÎèÑ Ïö¥ÏòÅÏßÑÏùÄ ÎÇ¥Ïö©ÏùÑ ÌôïÏù∏Ìï† Ïàò ÏóÜÏäµÎãàÎã§.*"
                )
                self.cog.logger.info(f"‚ùå {member.display_name}ÎãòÏóêÍ≤å Î∂àÌï©Í≤© ÏïàÎÇ¥ DM Ï†ÑÏÜ° ÏôÑÎ£å.")
            except discord.Forbidden:
                self.cog.logger.warning(f"‚ùå {member.display_name} ({member.id})ÎãòÏóêÍ≤å DMÏùÑ Î≥¥ÎÇº Ïàò ÏóÜÏäµÎãàÎã§. (DMÏù¥ ÎπÑÌôúÏÑ±ÌôîÎêòÏóàÍ±∞ÎÇò Ï∞®Îã®Îê®)")
                await interaction.followup.send(f"‚ùå {member.mention}ÎãòÏùÑ Î∂àÌï©Í≤© Ï≤òÎ¶¨ÌñàÏäµÎãàÎã§. (DM Ï†ÑÏÜ° Ïã§Ìå®: DMÏù¥ ÎπÑÌôúÏÑ±ÌôîÎêòÏóàÏùÑ Ïàò ÏûàÏäµÎãàÎã§.)")
                return

            applicant_role = interaction.guild.get_role(APPLICANT_ROLE_ID)
            if applicant_role and applicant_role in member.roles:
                await member.remove_roles(applicant_role, reason="Î∂àÌï©Í≤© Ï≤òÎ¶¨Î°ú Ïù∏Ìïú ÏßÄÏõêÏûê Ïó≠Ìï† Ï†úÍ±∞")
                self.cog.logger.info(f"ÏßÄÏõêÏûê Ïó≠Ìï† '{applicant_role.name}'ÏùÑ(Î•º) {member.display_name}ÎãòÏóêÍ≤åÏÑú Ï†úÍ±∞ÌñàÏäµÎãàÎã§.")

            await interaction.followup.send(f"‚ùå {member.mention}ÎãòÏùÑ Î∂àÌï©Í≤© Ï≤òÎ¶¨ÌñàÏäµÎãàÎã§.")
            self.cog.logger.info(f"‚ùå {member.display_name} ({member.id})ÎãòÏùÑ Î∂àÌï©Í≤© Ï≤òÎ¶¨ÌñàÏäµÎãàÎã§.")

            # Delete the channel after rejection
            await self.cog.delete_channel_after_delay(interaction.channel, 10, member.id, False)

        except Exception as e:
            self.cog.logger.error(f"‚ùå Î∂àÌï©Í≤© Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò Î∞úÏÉù: {e}\n{traceback.format_exc()}")
            await interaction.followup.send(f"‚ùå Ïò§Î•ò Î∞úÏÉù: {str(e)}", ephemeral=True)


class InterviewModal(Modal, title="Ïù∏ÌÑ∞Î∑∞ ÏÇ¨Ï†Ñ ÏßàÎ¨∏"):
    def __init__(self):
        super().__init__()
        self.answers = {}

        self.add_item(TextInput(
            label="ÌôúÎèô ÏßÄÏó≠ (ÏÑúÎ∂Ä/Ï§ëÎ∂Ä/ÎèôÎ∂Ä)",
            placeholder="Ïòà: Ï§ëÎ∂Ä",
            style=TextStyle.short,
            required=True,
            max_length=20
        ))
        self.add_item(TextInput(
            label="Ïù∏Í≤åÏûÑ Ïù¥Î¶Ñ Î∞è ÌÉúÍ∑∏ (Ïòà: Ïù¥Î¶Ñ#ÌÉúÍ∑∏)",
            placeholder="Ïòà: ÎùºÏù¥ÏóáÏù¥Î¶Ñ#ÎùºÏù¥ÏóáÌÉúÍ∑∏",
            style=TextStyle.short,
            required=True,
            max_length=50
        ))
        self.add_item(TextInput(
            label="Í∞ÄÏû• ÏûêÏã†ÏûàÎäî Ïó≠Ìï†",
            placeholder="Ïòà: ÌÉÄÍ≤©ÎåÄ, Í∞êÏãúÏûê, Ï≤ôÌõÑÎåÄ Îì±",
            style=TextStyle.short,
            required=True,
            max_length=30
        ))
        self.add_item(TextInput(
            label="ÌîÑÎ¶¨ÎØ∏Ïñ¥ ÌåÄ Ï∞∏Í∞Ä ÏùòÌñ•",
            placeholder="Ïòà: ÎÑ§ / ÏïÑÎãàÏöî",
            style=TextStyle.short,
            required=True,
            max_length=10
        ))
        self.add_item(TextInput(
            label="ÏßÄÏõê ÎèôÍ∏∞",
            placeholder="ExceedÏóê ÏßÄÏõêÌïòÍ≤å Îêú Ïù¥Ïú†Î•º Í∞ÑÎã®Ìûà Ï†ÅÏñ¥Ï£ºÏÑ∏Ïöî.",
            style=TextStyle.paragraph,
            required=True,
            max_length=300
        ))

    async def on_submit(self, interaction: discord.Interaction):
        # Defer the interaction as submitting modal might take time to process
        # Modals inherently handle their own response, so direct defer is not usually needed for the modal itself
        # but for actions taken AFTER the modal submission, you might want to defer again or use followup.
        # Here we just respond to the modal, then do work and send a followup at the end.

        for item in self.children:
            self.answers[item.label] = item.value.strip()

        region = self.answers.get("ÌôúÎèô ÏßÄÏó≠ (ÏÑúÎ∂Ä/Ï§ëÎ∂Ä/ÎèôÎ∂Ä)", "")
        if region not in ("ÏÑúÎ∂Ä", "Ï§ëÎ∂Ä", "ÎèôÎ∂Ä"):
            # Acknowledge the modal submission immediately with an ephemeral error
            await interaction.response.send_message(
                "‚ùå Ïò¨Î∞îÎ•∏ ÌôúÎèô ÏßÄÏó≠ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî (ÏÑúÎ∂Ä, Ï§ëÎ∂Ä, ÎèôÎ∂Ä Ï§ë ÌïòÎÇò).",
                ephemeral=True
            )
            return

        cog = interaction.client.get_cog("InterviewRequestCog")
        if not cog:
            fallback_logger = get_logger("interview_modal_fallback")
            fallback_logger.error("‚ùå Ïù∏ÌÑ∞Î∑∞ ÏΩîÍ∑∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. on_submitÏóêÏÑú.")
            await interaction.response.send_message( # Use response as this is the direct reply to modal
                "‚ùå Ïù∏ÌÑ∞Î∑∞ ÏΩîÍ∑∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.",
                ephemeral=True
            )
            return

        private_channel = interaction.guild.get_channel(cog.private_channel_id)
        if not private_channel:
            cog.logger.error(f"‚ùå ÎπÑÍ≥µÍ∞ú Ï±ÑÎÑêÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. ID: {cog.private_channel_id}")
            await interaction.response.send_message( # Use response as this is the direct reply to modal
                "‚ùå ÎπÑÍ≥µÍ∞ú Ï±ÑÎÑêÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.",
                ephemeral=True
            )
            return

        interview_id = str(uuid.uuid4()) # Generate unique interview ID
        submission_time = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

        sheet_data = [
            interview_id,
            submission_time,
            str(interaction.user.id), # Store as string
            interaction.user.display_name,
            self.answers.get("ÌôúÎèô ÏßÄÏó≠ (ÏÑúÎ∂Ä/Ï§ëÎ∂Ä/ÎèôÎ∂Ä)", ""),
            self.answers.get("Ïù∏Í≤åÏûÑ Ïù¥Î¶Ñ Î∞è ÌÉúÍ∑∏ (Ïòà: Ïù¥Î¶Ñ#ÌÉúÍ∑∏)", ""),
            self.answers.get("Í∞ÄÏû• ÏûêÏã†ÏûàÎäî Ïó≠Ìï†", ""),
            self.answers.get("ÌîÑÎ¶¨ÎØ∏Ïñ¥ ÌåÄ Ï∞∏Í∞Ä ÏùòÌñ•", ""),
            self.answers.get("ÏßÄÏõê ÎèôÍ∏∞", ""),
            "Pending" # Initial status
        ]

        if cog.gspread_client:
            success = await cog.gspread_client.append_row(config.TEST_SHEET_NAME, "Sheet1", sheet_data)
            if not success:
                cog.logger.error(f"‚ùå Google SheetÏóê Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä Ïã§Ìå®: {interaction.user.display_name}Ïùò Ïù∏ÌÑ∞Î∑∞ ÏöîÏ≤≠.")
                await interaction.response.send_message( # Use response as this is the direct reply to modal
                    "‚ùå Ïù∏ÌÑ∞Î∑∞ ÏöîÏ≤≠Ïù¥ Ï†ÑÏÜ°ÎêòÏóàÏúºÎÇò, Google SheetÏóê Í∏∞Î°ùÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Í¥ÄÎ¶¨ÏûêÏóêÍ≤å Î¨∏ÏùòÌïòÏÑ∏Ïöî.",
                    ephemeral=True
                )
                return

        embed = discord.Embed(
            title="üìù Ïù∏ÌÑ∞Î∑∞ ÏöîÏ≤≠ Ï†ëÏàò",
            description=f"{interaction.user.mention} ÎãòÏù¥ Ïù∏ÌÑ∞Î∑∞Î•º ÏöîÏ≤≠ÌñàÏäµÎãàÎã§.",
            color=discord.Color.green(),
            timestamp=datetime.datetime.now(timezone.utc)
        )

        embed.set_thumbnail(url=interaction.user.display_avatar.url)
        embed.set_author(name="Exceed Ïù∏ÌÑ∞Î∑∞ ÏãúÏä§ÌÖú")

        for question, answer in self.answers.items():
            embed.add_field(
                name=f"‚ùì {question}",
                value=f"> {answer or '*ÏùëÎãµ ÏóÜÏùå*'}",
                inline=False
            )
        embed.add_field(name="‚ùì Interview_ID", value=f"> {interview_id}", inline=False) # Add interview ID to embed

        view = DecisionButtonView(cog=cog) # Pass cog to the view
        await private_channel.send(embed=embed, view=view)
        cog.logger.info(f"Ïù∏ÌÑ∞Î∑∞ ÏöîÏ≤≠ Ï†ëÏàò: {interaction.user.display_name} ({interaction.user.id}), Interview ID: {interview_id}")

        await interaction.response.send_message(
            "‚úÖ Ïù∏ÌÑ∞Î∑∞ ÏöîÏ≤≠Ïù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï†ÑÏÜ°ÎêòÏóàÏäµÎãàÎã§!",
            ephemeral=True
        )


class InterviewView(View):
    def __init__(self, private_channel_id: int, cog):
        super().__init__(timeout=None)
        self.private_channel_id = private_channel_id
        self.cog = cog

    @discord.ui.button(label="Ïù∏ÌÑ∞Î∑∞ ÏöîÏ≤≠ ÏãúÏûëÌïòÍ∏∞", style=discord.ButtonStyle.primary, custom_id="start_interview")
    async def start_interview(self, interaction: discord.Interaction, button: Button):

        modal = InterviewModal()
        await interaction.response.send_modal(modal)

class InterviewRequestCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.public_channel_id = INTERVIEW_PUBLIC_CHANNEL_ID
        self.private_channel_id = INTERVIEW_PRIVATE_CHANNEL_ID

        self.logger = get_logger( # Use get_logger from utils.logger directly
            "ÌÅ¥Îûú Ïù∏ÌÑ∞Î∑∞",
            bot=bot,
            discord_log_channel_id=config.LOG_CHANNEL_ID
        )
        self.logger.info("InterviewRequestCog Ï¥àÍ∏∞Ìôî ÏôÑÎ£å.")

        self.gspread_client = GSpreadClient(config.GSHEET_CREDENTIALS_PATH, self.logger)
        self.logger.info("Google Sheets client instance created.")

        self.FONT = None
        try:
            self.CONGRATS_BG_PATH = getattr(config, 'CONGRATS_BG_PATH', os.path.join("assets", "congrats_bg.gif"))
            FONT_PATH_CONFIG = getattr(config, 'FONT_PATH', os.path.join("assets", "fonts", "NotoSansKR-Bold.ttf"))
            self.FONT = ImageFont.truetype(FONT_PATH_CONFIG, 72)
            self.logger.info(f"Ìè∞Ìä∏ Î°úÎìú ÏÑ±Í≥µ: {FONT_PATH_CONFIG}")
        except ImportError:
            self.logger.warning("Pillow ImageFontÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. Í∏∞Î≥∏ Ìè∞Ìä∏Î•º ÏÇ¨Ïö©Ìï©ÎãàÎã§.")
            self.FONT = ImageDraw.Draw(Image.new('RGBA', (1, 1))).getfont()
        except IOError:
            self.logger.warning(f"Ìè∞Ìä∏ ÌååÏùºÏù¥ '{FONT_PATH_CONFIG}' Í≤ΩÎ°úÏóêÏÑú Î∞úÍ≤¨ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Í∏∞Î≥∏ Ìè∞Ìä∏Î•º ÏÇ¨Ïö©Ìï©ÎãàÎã§.")
            self.FONT = ImageDraw.Draw(Image.new('RGBA', (1, 1))).getfont()
        except Exception as e:
            self.logger.error(f"Ìè∞Ìä∏ Î°úÎìú Ï§ë Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò Î∞úÏÉù: {e}\n{traceback.format_exc()}")
            self.FONT = ImageDraw.Draw(Image.new('RGBA', (1, 1))).getfont()

    def extract_interview_id_from_channel_name(self, channel_name: str) -> Optional[str]:
        # This function might not be strictly needed if we rely on embed for ID
        match = re.search(r'-([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$',
                          channel_name)
        if match:
            return match.group(1)
        return None

    def extract_user_id_from_channel_name(self, channel_name: str) -> Optional[int]:
        # This function might not be strictly needed if we rely on embed for ID
        match = re.search(r'interview-(\d{17,20})(?:-|$)', channel_name)
        if match:
            return int(match.group(1))
        return None

    def check_staff_role(self, member: discord.Member) -> bool:
        """Checks if a member has the configured staff role."""
        if not config.STAFF_ROLE_ID:
            self.logger.warning(
                "‚ö†Ô∏è STAFF_ROLE_ID is not configured in config.py. All users will be denied staff access.")
            return False

        staff_role = member.guild.get_role(config.STAFF_ROLE_ID)
        if not staff_role:
            self.logger.error(
                f"‚ùå Staff role with ID {config.STAFF_ROLE_ID} not found in guild {member.guild.name}.")
            return False

        return staff_role in member.roles

    async def make_congrats_card(self, member: discord.Member) -> Optional[BytesIO]:
        try:
            bg = Image.open(self.CONGRATS_BG_PATH).convert("RGBA")
        except FileNotFoundError:
            self.logger.error(f"Ï∂ïÌïò Î∞∞Í≤Ω Ïù¥ÎØ∏ÏßÄÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: {self.CONGRATS_BG_PATH}")
            return None
        except Exception as e:
            self.logger.error(f"Î∞∞Í≤Ω Ïù¥ÎØ∏ÏßÄ Î°úÎìú Ï§ë Ïò§Î•ò Î∞úÏÉù: {e}\n{traceback.format_exc()}")
            return None

        draw = ImageDraw.Draw(bg)

        avatar_asset = member.display_avatar.with_size(128).with_format("png")
        try:
            avatar_bytes = await asyncio.wait_for(avatar_asset.read(), timeout=5)
        except asyncio.TimeoutError:
            self.logger.error(f"‚ùå [congrats] {member.display_name}Ïùò ÏïÑÎ∞îÌÉÄÎ•º Í∞ÄÏ†∏Ïò§Îäî Îç∞ ÏãúÍ∞Ñ Ï¥àÍ≥º.")
            avatar_bytes = None
        except Exception as e:
            self.logger.error(f"‚ùå [congrats] {member.display_name}Ïùò ÏïÑÎ∞îÌÉÄ Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®: {e}\n{traceback.format_exc()}")
            avatar_bytes = None

        if avatar_bytes:
            try:
                avatar = Image.open(BytesIO(avatar_bytes)).resize((128, 128)).convert("RGBA")
                avatar_x = 40
                avatar_y = (bg.height - avatar.height) // 2
                bg.paste(avatar, (avatar_x, avatar_y), avatar)
            except Exception as e:
                self.logger.error(f"ÏïÑÎ∞îÌÉÄ Ïù¥ÎØ∏ÏßÄ Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò Î∞úÏÉù: {e}\n{traceback.format_exc()}")
        else:
            self.logger.warning(f"ÏïÑÎ∞îÌÉÄÎ•º Í∞ÄÏ†∏Ïò§ÏßÄ Î™ªÌïòÏó¨ {member.display_name}Ïùò Ï∂ïÌïò Ïπ¥ÎìúÏóê ÏïÑÎ∞îÌÉÄÎ•º Ï∂îÍ∞ÄÌï† Ïàò ÏóÜÏäµÎãàÎã§.")

        text = f"Ï∂ïÌïòÌï©ÎãàÎã§, {member.display_name}Îãò!"

        current_font = self.FONT if self.FONT else ImageDraw.Draw(Image.new('RGBA', (1, 1))).getfont()

        # Calculate text bounding box
        text_bbox = draw.textbbox((0, 0), text, font=current_font)
        text_width = text_bbox[2] - text_bbox[0]
        text_height = text_bbox[3] - text_bbox[1]

        avatar_width_used = 128 if avatar_bytes else 0
        text_x = 40 + avatar_width_used + 30
        text_y = (bg.height - text_height) // 2

        draw.text((text_x, text_y), text, font=current_font, fill="white")

        buf = BytesIO()
        try:
            bg.save(buf, "PNG")
            buf.seek(0)
            return buf
        except Exception as e:
            self.logger.error(f"Ï∂ïÌïò Ïπ¥Îìú Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû• Ï§ë Ïò§Î•ò Î∞úÏÉù: {e}\n{traceback.format_exc()}")
            return None

    async def send_welcome_message(self, member: discord.Member):
        """Send welcome message to welcome channel"""
        channel = self.bot.get_channel(WELCOME_CHANNEL_ID)
        if not channel:
            self.logger.error(f"ÌôòÏòÅ Ï±ÑÎÑê ID {WELCOME_CHANNEL_ID}ÏùÑ(Î•º) Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")
            return

        file = None
        try:
            card_buf = await self.make_congrats_card(member)
            if card_buf:
                file = File(card_buf, filename="welcome.png")
            else:
                self.logger.warning(f"{member.display_name}ÎãòÏùò ÌôòÏòÅ Ïπ¥Îìú ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. ÌååÏùº ÏóÜÏù¥ Î©îÏãúÏßÄÎ•º Î≥¥ÎÉÖÎãàÎã§.")

            embed = discord.Embed(
                title=f"üéâ {member.display_name}Îãò, Exceed ÌÅ¥ÎûúÏóê Ìï©Í≤©ÌïòÏÖ®ÏäµÎãàÎã§!",
                description="Ï∂ïÌïòÎìúÎ¶ΩÎãàÎã§! Í≥µÏãù ÌÅ¥Îûú Î©§Î≤ÑÍ∞Ä ÎêòÏã† Í≤ÉÏùÑ ÏßÑÏã¨ÏúºÎ°ú ÌôòÏòÅÌï©ÎãàÎã§.",
                color=discord.Color.gold(),
                timestamp=datetime.datetime.now(timezone.utc)
            )
            embed.add_field(name="1Ô∏è‚É£ ÌÅ¥Îûú Í∑úÏπôÏùÑ Íº≠ ÌôïÏù∏Ìï¥ Ï£ºÏÑ∏Ïöî!", value=f"<#{config.RULES_CHANNEL_ID}>", inline=False)
            embed.add_field(name="2Ô∏è‚É£ Ïó≠Ìï†ÏßÄÍ∏â Ï±ÑÎÑêÏóêÏÑú ÏõêÌïòÎäî Ïó≠Ìï†ÏùÑ ÏÑ†ÌÉùÌï¥ Ï£ºÏÑ∏Ïöî.", value=f"<#{config.ROLE_ASSIGN_CHANNEL_ID}>",
                            inline=False)
            embed.add_field(name="3Ô∏è‚É£ Î©§Î≤Ñ Ï†ÑÏö© Ï±ÑÌåÖÎ∞©ÏùÑ ÌôïÏù∏Ìï¥ Î≥¥ÏÑ∏Ïöî.", value=f"<#{config.MEMBER_CHAT_CHANNEL_ID}>", inline=False)
            embed.add_field(name="4Ô∏è‚É£ ÌÅ¥Îûú MMR ÏãúÏä§ÌÖúÏùÑ Í∏∞Î∞òÏúºÎ°ú Ìïú ÌÅ¥Îûú Î¶¨ÎçîÎ≥¥ÎìúÎ•º ÌôïÏù∏Ìï¥ Î≥¥ÏÑ∏Ïöî.",
                            value=f"<#{config.CLAN_LEADERBOARD_CHANNEL_ID}>", inline=False)

            if file:
                embed.set_image(url="attachment://welcome.png")

            embed.set_footer(text="Exceed ‚Ä¢ Ìï©Í≤© Ï∂ïÌïò Î©îÏãúÏßÄ", icon_url=self.bot.user.display_avatar.url)

            await channel.send(
                content=member.mention,
                embed=embed,
                file=file,
                allowed_mentions=discord.AllowedMentions(users=True))
            self.logger.info(f"ÌôòÏòÅ Î©îÏãúÏßÄ Ï†ÑÏÜ° ÏôÑÎ£å: {member.display_name} ({member.id})")

        except Exception as e:
            self.logger.error(f"ÌôòÏòÅ Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïã§Ìå®: {str(e)}\n{traceback.format_exc()}")

    async def delete_channel_after_delay(self, channel: discord.TextChannel, delay: int, member_id: int, is_accepted: bool):
        self.logger.info(f"Channel {channel.name} ({channel.id}) will be deleted in {delay} seconds.")
        await asyncio.sleep(delay)
        try:
            if channel:
                await channel.delete(reason=f"Interview process completed (Member ID: {member_id}, Accepted: {is_accepted})")
                self.logger.info(f"Channel {channel.name} ({channel.id}) deleted successfully.")
        except discord.Forbidden:
            self.logger.error(f"‚ùå Missing permissions to delete channel {channel.name} ({channel.id}).")
        except discord.HTTPException as e:
            self.logger.error(f"‚ùå HTTP error while deleting channel {channel.name} ({channel.id}): {e}")
        except Exception as e:
            self.logger.error(f"‚ùå Unknown error while deleting channel {channel.name} ({channel.id}): {e}\n{traceback.format_exc()}")

    async def send_interview_request_message(self):
        channel = self.bot.get_channel(self.public_channel_id)
        if not channel:
            self.logger.error(f"Í≥µÍ∞ú Ï±ÑÎÑê ID {self.public_channel_id}Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")
            return

        try:
            await channel.purge(limit=None)
            self.logger.info(f"Ï±ÑÎÑê #{channel.name} ({channel.id})Ïùò Í∏∞Ï°¥ Î©îÏãúÏßÄÎ•º ÏÇ≠Ï†úÌñàÏäµÎãàÎã§.")

            rules_embed = discord.Embed(
                title="üéØ XCD Î∞úÎ°úÎûÄÌä∏ ÌÅ¥Îûú Í∞ÄÏûÖ Ï°∞Í±¥ ÏïàÎÇ¥",
                description="üìú ÏµúÏ¢Ö ÏóÖÎç∞Ïù¥Ìä∏: 2025.07.06",
                color=discord.Color.orange()
            )
            rules_embed.add_field(
                name="Í∞ÄÏûÖ Ï†Ñ ÏïÑÎûò Ï°∞Í±¥ÏùÑ Î∞òÎìúÏãú ÌôïÏù∏Ìï¥ Ï£ºÏÑ∏Ïöî.",
                value=(
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                    "üîû 1. ÎÇòÏù¥ Ï°∞Í±¥\n"
                    "„ÉªÎßå 20ÏÑ∏ Ïù¥ÏÉÅ (2005ÎÖÑÏÉù Ïù¥Ï†Ñ)\n"
                    "„ÉªÏÑ±ÏàôÌïú Ïª§ÎÆ§ÎãàÏºÄÏù¥ÏÖòÍ≥º Ï±ÖÏûÑÍ∞ê ÏûàÎäî ÌñâÎèôÏùÑ Í∏∞ÎåÄÌï©ÎãàÎã§.\n\n"
                    "üéÆ 2. Ïã§Î†• Ï°∞Í±¥\n"
                    "„ÉªÌòÑÏû¨ Ìã∞Ïñ¥ Í≥®Îìú Ïù¥ÏÉÅ (ÏóêÌîºÏÜåÎìú Í∏∞Ï§Ä)\n"
                    "„ÉªÌä∏ÎùºÏù¥ÏïÑÏõÉ(Ïä§ÌÅ¨Î¶º ÌÖåÏä§Ìä∏)ÏúºÎ°ú Ïã§Î†• ÌôïÏù∏ Í∞ÄÎä•\n"
                    "„ÉªÍ≤åÏûÑ Ïù¥Ìï¥ÎèÑ & ÌåÄÏõåÌÅ¨ÎèÑ Ìï®Íªò ÌèâÍ∞Ä\n\n"
                    "üí¨ 3. Îß§ÎÑà & ÏÜåÌÜµ\n"
                    "„ÉªÏöïÏÑ§/Î¨¥Ïãú/Ï°∞Î°±/Î∞òÎßê Îì± ÎπÑÎß§ÎÑà Ïñ∏Ìñâ Í∏àÏßÄ\n"
                    "„ÉªÌîºÎìúÎ∞±ÏùÑ Î∞õÏïÑÎì§Ïù¥Í≥† Í∏çÏ†ïÏ†ÅÏù∏ ÌÉúÎèÑÎ°ú Í≤åÏûÑ Í∞ÄÎä•\n"
                    "„ÉªÎîîÏä§ÏΩîÎìú ÎßàÏù¥ÌÅ¨ ÌïÑÏàò\n\n"
                    "‚è±Ô∏è 4. ÌôúÎèôÏÑ±\n"
                    "„ÉªÏ£º 3Ìöå Ïù¥ÏÉÅ Ï†ëÏÜç & Í≤åÏûÑ Ï∞∏Ïó¨ Í∞ÄÎä•Ïûê\n"
                    "„ÉªÎåÄÌöå/Ïä§ÌÅ¨Î¶º/ÎÇ¥Ï†Ñ Îì± ÏùºÏ†ïÏóê Ï†ÅÍ∑π Ï∞∏Ïó¨Ìï† ÏùòÌñ• ÏûàÎäî Î∂Ñ\n"
                    "„Éª30Ïùº Ïù¥ÏÉÅ ÎØ∏Ï†ëÏÜç Ïãú ÏûêÎèô ÌÉàÌá¥ Ï≤òÎ¶¨ Í∞ÄÎä•\n\n"
                    "üö´ 5. Ï†úÌïú ÎåÄÏÉÅ\n"
                    "„ÉªÎã§Î•∏ ÌÅ¥ÎûúÍ≥º Í≤πÏπòÎäî ÌôúÎèô Ï§ëÏù∏ Ïú†Ï†Ä\n"
                    "„ÉªÌä∏Î°§, ÏöïÏÑ§, Î∞¥ Ïù¥Î†• Îì± Ï†úÏû¨ Í∏∞Î°ù ÏûàÎäî Ïú†Ï†Ä\n"
                    "„ÉªÎåÄÎ¶¨/Î∂ÄÍ≥ÑÏ†ï/Í≥ÑÏ†ï Í≥µÏú† Îì± ÎπÑÏ†ïÏÉÅ ÌôúÎèô\n"
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                ),
                inline=False
            )
            rules_embed.add_field(
                name="üìã Í∞ÄÏûÖ Ï†àÏ∞®",
                value=(
                    "1Ô∏è‚É£ ÎîîÏä§ÏΩîÎìú ÏÑúÎ≤Ñ ÏûÖÏû•\n"
                    "2Ô∏è‚É£ Í∞ÄÏûÖ ÏßÄÏõêÏÑú ÏûëÏÑ± or Ïù∏ÌÑ∞Î∑∞\n"
                    "3Ô∏è‚É£ Ìä∏ÎùºÏù¥ÏïÑÏõÉ or ÏµúÍ∑º Í≤ΩÍ∏∞ ÌÅ¥Î¶Ω ÌôïÏù∏\n"
                    "4Ô∏è‚É£ Ïö¥ÏòÅÏßÑ ÏäπÏù∏ ‚Üí Ïó≠Ìï† Î∂ÄÏó¨ ÌõÑ Í∞ÄÏûÖ ÏôÑÎ£å"
                ),
                inline=False
            )
            rules_embed.add_field(
                name="üß† FAQ",
                value=(
                    "Q. ÎßàÏù¥ÌÅ¨ ÏóÜÏúºÎ©¥ Í∞ÄÏûÖ Ïïà ÎêòÎÇòÏöî?\n"
                    "‚Üí ÎÑ§. ÏùåÏÑ± ÏÜåÌÜµÏùÄ ÌïÑÏàòÏûÖÎãàÎã§. ÌÖçÏä§Ìä∏ÎßåÏúºÎ°úÎäî ÌôúÎèôÏù¥ Ïñ¥Î†µÏäµÎãàÎã§.\n\n"
                    "Q. Í≥®Îìú ÎØ∏ÎßåÏù∏Îç∞ Îì§Ïñ¥Í∞à Ïàò ÏûàÎÇòÏöî?\n"
                    "‚Üí Ìä∏ÎùºÏù¥ÏïÑÏõÉÏúºÎ°ú ÌåÄÏõåÌÅ¨/Ïù¥Ìï¥ÎèÑ ÌôïÏù∏ ÌõÑ ÏòàÏô∏ ÏäπÏù∏Îê† Ïàò ÏûàÏäµÎãàÎã§."
                ),
                inline=False
            )
            rules_embed.set_footer(
                text="‚úÖ Í∞ÄÏûÖ ÌõÑ ÏùºÏ†ï Í∏∞Í∞Ñ Ï†ÅÏùë ÌèâÍ∞Ä Í∏∞Í∞ÑÏù¥ ÏûàÏúºÎ©∞\n"
                     "Îß§ÎÑà, Ï∞∏Ïó¨ÎèÑ Î∂ÄÏ°± Ïãú Í≤ΩÍ≥† ÏóÜÏù¥ ÌÉàÌá¥Îê† Ïàò ÏûàÏäµÎãàÎã§.\n\n"
                     "üìå Î≥∏ ÏïàÎÇ¥Îäî ÌÅ¥Îûú Ïö¥ÏòÅ ÏÉÅÌô©Ïóê Îî∞Îùº Î≥ÄÍ≤ΩÎê† Ïàò ÏûàÏäµÎãàÎã§."
            )

            await channel.send(embed=rules_embed)

            interview_embed = discord.Embed(
                title="‚ú® Ïù∏ÌÑ∞Î∑∞ ÏöîÏ≤≠ ÏïàÎÇ¥ ‚ú®",
                description=(
                    "Exceed ÌÅ¥ÎûúÏóê ÏßÄÏõêÌïòÍ≥† Ïã∂ÏúºÏã†Í∞ÄÏöî?\n"
                    "ÏïÑÎûò Î≤ÑÌäºÏùÑ ÎàåÎü¨ Ïù∏ÌÑ∞Î∑∞ ÏöîÏ≤≠ÏùÑ ÏãúÏûëÌïòÏÑ∏Ïöî.\n"
                    "Ïã†ÏÜçÌïòÍ≤å ÌôïÏù∏ ÌõÑ Ïó∞ÎùΩÎìúÎ¶¨Í≤†ÏäµÎãàÎã§."
                ),
                color=discord.Color.blue(),
                timestamp=datetime.datetime.now(timezone.utc)
            )
            interview_embed.set_thumbnail(url="https://cdn-icons-png.flaticon.com/512/1041/1041916.png")
            interview_embed.set_footer(text="Exceed ‚Ä¢ Ïù∏ÌÑ∞Î∑∞ ÏãúÏä§ÌÖú")
            interview_embed.set_author(
                name="Exceed Ïù∏ÌÑ∞Î∑∞ ÏïàÎÇ¥",
                icon_url="https://cdn-icons-png.flaticon.com/512/295/295128.png"
            )

            await channel.send(embed=interview_embed, view=InterviewView(self.private_channel_id, self))
            self.logger.info("üì®„ÉªÏßÄÏõêÏÑú-Ï†úÏ∂ú Ï±ÑÎÑêÏóê Í∞ÄÏûÖ Ï°∞Í±¥ ÏïàÎÇ¥ Î∞è Ïù∏ÌÑ∞Î∑∞ Î≤ÑÌäºÏùÑ Í≤åÏãúÌñàÏäµÎãàÎã§.")

        except Exception as e:
            self.logger.error(f"Ïù∏ÌÑ∞Î∑∞ ÏöîÏ≤≠ Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïã§Ìå®: {e}\n{traceback.format_exc()}")


    @commands.Cog.listener()
    async def on_ready(self):
        # Pass cog to DecisionButtonView for persistence
        self.bot.add_view(InterviewView(self.private_channel_id, self))
        self.bot.add_view(DecisionButtonView(cog=self))
        await self.send_interview_request_message()
        self.logger.info("Ïù∏ÌÑ∞Î∑∞ ÏöîÏ≤≠ Î©îÏãúÏßÄ Î∞è ÏòÅÍµ¨ Î∑∞ ÏÑ§Ï†ï ÏôÑÎ£å.")

    @discord.app_commands.command(
        name="request_interview",
        description="Ïù∏ÌÑ∞Î∑∞ ÏöîÏ≤≠ Î©îÏãúÏßÄÎ•º Îã§Ïãú Î≥¥ÎÉÖÎãàÎã§ (Í¥ÄÎ¶¨ÏûêÏö©)"
    )
    @discord.app_commands.default_permissions(administrator=True)
    async def slash_request_interview(self, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=True)
        await self.send_interview_request_message()
        await interaction.followup.send(
            "Ïù∏ÌÑ∞Î∑∞ ÏöîÏ≤≠ Î©îÏãúÏßÄÎ•º Í∞±Ïã†ÌñàÏäµÎãàÎã§!",
            ephemeral=True
        )


async def setup(bot):
    await bot.add_cog(InterviewRequestCog(bot))